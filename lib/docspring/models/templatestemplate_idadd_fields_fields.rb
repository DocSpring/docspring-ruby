=begin
#API v1

#DocSpring is a service that helps you fill out and sign PDF templates.

OpenAPI spec version: v1

Generated by: https://openapi-generator.tech
OpenAPI Generator version: 3.3.0-SNAPSHOT

=end

require 'date'

module DocSpring
  class TemplatestemplateIdaddFieldsFields
    attr_accessor :uppercase

    attr_accessor :background_color_field_name

    attr_accessor :metadata

    attr_accessor :barcode_symbology

    attr_accessor :min_length

    attr_accessor :integer

    attr_accessor :type

    attr_accessor :required

    attr_accessor :comb_value_offset

    attr_accessor :image_gravity

    attr_accessor :overflow

    attr_accessor :qrcode_color

    attr_accessor :color_field_required

    attr_accessor :background_color_field_required

    attr_accessor :id

    attr_accessor :image_scale_type

    attr_accessor :exclusive_minimum

    attr_accessor :height

    attr_accessor :number_condition_range_exclusive_max

    attr_accessor :invert_boolean_condition

    attr_accessor :static

    attr_accessor :shape_fill_color_field_name

    attr_accessor :shape_border_color_field_name

    attr_accessor :v_alignment

    attr_accessor :bold

    attr_accessor :shape_border_width

    attr_accessor :comb_number_of_cells

    attr_accessor :shape_border_color

    attr_accessor :typeface

    attr_accessor :comb

    attr_accessor :shape_type

    attr_accessor :display_type

    attr_accessor :condition

    attr_accessor :check_color

    attr_accessor :multiline_lines

    attr_accessor :multiline

    attr_accessor :true_text

    attr_accessor :name

    attr_accessor :font_size

    attr_accessor :page

    attr_accessor :alignment

    attr_accessor :max_length

    attr_accessor :auto_calculate_max_length

    attr_accessor :color_field_name

    attr_accessor :qrcode_color_field_name

    attr_accessor :number_condition_range_min

    attr_accessor :hidden

    attr_accessor :color

    attr_accessor :check_color_field_required

    attr_accessor :combined_field_format

    attr_accessor :description

    attr_accessor :shape_border_color_field_required

    attr_accessor :combined_field_names

    attr_accessor :title

    attr_accessor :number_condition_range_exclusive_min

    attr_accessor :combined_field_separator

    attr_accessor :exclusive_maximum

    attr_accessor :default

    attr_accessor :combined_field_type

    attr_accessor :date_time_format

    attr_accessor :qrcode_color_field_required

    attr_accessor :currency

    attr_accessor :strikethrough

    attr_accessor :false_text

    attr_accessor :character_spacing

    attr_accessor :number_condition_range_max

    attr_accessor :background_color

    attr_accessor :check_color_field_name

    attr_accessor :check_character

    attr_accessor :rotation

    attr_accessor :option_list

    attr_accessor :shape_fill_color

    attr_accessor :string_condition_type

    attr_accessor :shape_fill_color_field_required

    attr_accessor :include_time

    attr_accessor :decimal_places

    attr_accessor :x

    attr_accessor :width

    attr_accessor :maximum

    attr_accessor :y

    attr_accessor :signature_allow_draw

    attr_accessor :opacity

    attr_accessor :number_condition_type

    attr_accessor :minimum

    attr_accessor :signature_allow_type

    class EnumAttributeValidator
      attr_reader :datatype
      attr_reader :allowable_values

      def initialize(datatype, allowable_values)
        @allowable_values = allowable_values.map do |value|
          case datatype.to_s
          when /Integer/i
            value.to_i
          when /Float/i
            value.to_f
          else
            value
          end
        end
      end

      def valid?(value)
        !value || allowable_values.include?(value)
      end
    end

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        :'uppercase' => :'uppercase',
        :'background_color_field_name' => :'backgroundColorFieldName',
        :'metadata' => :'metadata',
        :'barcode_symbology' => :'barcodeSymbology',
        :'min_length' => :'minLength',
        :'integer' => :'integer',
        :'type' => :'type',
        :'required' => :'required',
        :'comb_value_offset' => :'combValueOffset',
        :'image_gravity' => :'imageGravity',
        :'overflow' => :'overflow',
        :'qrcode_color' => :'qrcodeColor',
        :'color_field_required' => :'colorFieldRequired',
        :'background_color_field_required' => :'backgroundColorFieldRequired',
        :'id' => :'id',
        :'image_scale_type' => :'imageScaleType',
        :'exclusive_minimum' => :'exclusiveMinimum',
        :'height' => :'height',
        :'number_condition_range_exclusive_max' => :'numberConditionRangeExclusiveMax',
        :'invert_boolean_condition' => :'invertBooleanCondition',
        :'static' => :'static',
        :'shape_fill_color_field_name' => :'shapeFillColorFieldName',
        :'shape_border_color_field_name' => :'shapeBorderColorFieldName',
        :'v_alignment' => :'vAlignment',
        :'bold' => :'bold',
        :'shape_border_width' => :'shapeBorderWidth',
        :'comb_number_of_cells' => :'combNumberOfCells',
        :'shape_border_color' => :'shapeBorderColor',
        :'typeface' => :'typeface',
        :'comb' => :'comb',
        :'shape_type' => :'shapeType',
        :'display_type' => :'displayType',
        :'condition' => :'condition',
        :'check_color' => :'checkColor',
        :'multiline_lines' => :'multilineLines',
        :'multiline' => :'multiline',
        :'true_text' => :'trueText',
        :'name' => :'name',
        :'font_size' => :'fontSize',
        :'page' => :'page',
        :'alignment' => :'alignment',
        :'max_length' => :'maxLength',
        :'auto_calculate_max_length' => :'autoCalculateMaxLength',
        :'color_field_name' => :'colorFieldName',
        :'qrcode_color_field_name' => :'qrcodeColorFieldName',
        :'number_condition_range_min' => :'numberConditionRangeMin',
        :'hidden' => :'hidden',
        :'color' => :'color',
        :'check_color_field_required' => :'checkColorFieldRequired',
        :'combined_field_format' => :'combinedFieldFormat',
        :'description' => :'description',
        :'shape_border_color_field_required' => :'shapeBorderColorFieldRequired',
        :'combined_field_names' => :'combinedFieldNames',
        :'title' => :'title',
        :'number_condition_range_exclusive_min' => :'numberConditionRangeExclusiveMin',
        :'combined_field_separator' => :'combinedFieldSeparator',
        :'exclusive_maximum' => :'exclusiveMaximum',
        :'default' => :'default',
        :'combined_field_type' => :'combinedFieldType',
        :'date_time_format' => :'dateTimeFormat',
        :'qrcode_color_field_required' => :'qrcodeColorFieldRequired',
        :'currency' => :'currency',
        :'strikethrough' => :'strikethrough',
        :'false_text' => :'falseText',
        :'character_spacing' => :'characterSpacing',
        :'number_condition_range_max' => :'numberConditionRangeMax',
        :'background_color' => :'backgroundColor',
        :'check_color_field_name' => :'checkColorFieldName',
        :'check_character' => :'checkCharacter',
        :'rotation' => :'rotation',
        :'option_list' => :'optionList',
        :'shape_fill_color' => :'shapeFillColor',
        :'string_condition_type' => :'stringConditionType',
        :'shape_fill_color_field_required' => :'shapeFillColorFieldRequired',
        :'include_time' => :'includeTime',
        :'decimal_places' => :'decimalPlaces',
        :'x' => :'x',
        :'width' => :'width',
        :'maximum' => :'maximum',
        :'y' => :'y',
        :'signature_allow_draw' => :'signatureAllowDraw',
        :'opacity' => :'opacity',
        :'number_condition_type' => :'numberConditionType',
        :'minimum' => :'minimum',
        :'signature_allow_type' => :'signatureAllowType'
      }
    end

    # Attribute type mapping.
    def self.openapi_types
      {
        :'uppercase' => :'BOOLEAN',
        :'background_color_field_name' => :'String',
        :'metadata' => :'String',
        :'barcode_symbology' => :'String',
        :'min_length' => :'Float',
        :'integer' => :'BOOLEAN',
        :'type' => :'String',
        :'required' => :'BOOLEAN',
        :'comb_value_offset' => :'Float',
        :'image_gravity' => :'String',
        :'overflow' => :'String',
        :'qrcode_color' => :'String',
        :'color_field_required' => :'BOOLEAN',
        :'background_color_field_required' => :'BOOLEAN',
        :'id' => :'Float',
        :'image_scale_type' => :'String',
        :'exclusive_minimum' => :'BOOLEAN',
        :'height' => :'Float',
        :'number_condition_range_exclusive_max' => :'BOOLEAN',
        :'invert_boolean_condition' => :'BOOLEAN',
        :'static' => :'BOOLEAN',
        :'shape_fill_color_field_name' => :'String',
        :'shape_border_color_field_name' => :'String',
        :'v_alignment' => :'String',
        :'bold' => :'BOOLEAN',
        :'shape_border_width' => :'Float',
        :'comb_number_of_cells' => :'Float',
        :'shape_border_color' => :'String',
        :'typeface' => :'String',
        :'comb' => :'BOOLEAN',
        :'shape_type' => :'String',
        :'display_type' => :'String',
        :'condition' => :'String',
        :'check_color' => :'String',
        :'multiline_lines' => :'Float',
        :'multiline' => :'BOOLEAN',
        :'true_text' => :'String',
        :'name' => :'String',
        :'font_size' => :'Float',
        :'page' => :'Float',
        :'alignment' => :'String',
        :'max_length' => :'Float',
        :'auto_calculate_max_length' => :'BOOLEAN',
        :'color_field_name' => :'String',
        :'qrcode_color_field_name' => :'String',
        :'number_condition_range_min' => :'Float',
        :'hidden' => :'BOOLEAN',
        :'color' => :'String',
        :'check_color_field_required' => :'BOOLEAN',
        :'combined_field_format' => :'String',
        :'description' => :'String',
        :'shape_border_color_field_required' => :'BOOLEAN',
        :'combined_field_names' => :'String',
        :'title' => :'String',
        :'number_condition_range_exclusive_min' => :'BOOLEAN',
        :'combined_field_separator' => :'String',
        :'exclusive_maximum' => :'BOOLEAN',
        :'default' => :'String',
        :'combined_field_type' => :'String',
        :'date_time_format' => :'String',
        :'qrcode_color_field_required' => :'BOOLEAN',
        :'currency' => :'BOOLEAN',
        :'strikethrough' => :'BOOLEAN',
        :'false_text' => :'String',
        :'character_spacing' => :'Float',
        :'number_condition_range_max' => :'Float',
        :'background_color' => :'String',
        :'check_color_field_name' => :'String',
        :'check_character' => :'String',
        :'rotation' => :'Float',
        :'option_list' => :'String',
        :'shape_fill_color' => :'String',
        :'string_condition_type' => :'String',
        :'shape_fill_color_field_required' => :'BOOLEAN',
        :'include_time' => :'BOOLEAN',
        :'decimal_places' => :'Float',
        :'x' => :'Float',
        :'width' => :'Float',
        :'maximum' => :'Float',
        :'y' => :'Float',
        :'signature_allow_draw' => :'BOOLEAN',
        :'opacity' => :'Float',
        :'number_condition_type' => :'String',
        :'minimum' => :'Float',
        :'signature_allow_type' => :'BOOLEAN'
      }
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(attributes = {})
      return unless attributes.is_a?(Hash)

      # convert string to symbol for hash key
      attributes = attributes.each_with_object({}) { |(k, v), h| h[k.to_sym] = v }

      if attributes.has_key?(:'uppercase')
        self.uppercase = attributes[:'uppercase']
      end

      if attributes.has_key?(:'backgroundColorFieldName')
        self.background_color_field_name = attributes[:'backgroundColorFieldName']
      end

      if attributes.has_key?(:'metadata')
        self.metadata = attributes[:'metadata']
      end

      if attributes.has_key?(:'barcodeSymbology')
        self.barcode_symbology = attributes[:'barcodeSymbology']
      end

      if attributes.has_key?(:'minLength')
        self.min_length = attributes[:'minLength']
      end

      if attributes.has_key?(:'integer')
        self.integer = attributes[:'integer']
      end

      if attributes.has_key?(:'type')
        self.type = attributes[:'type']
      end

      if attributes.has_key?(:'required')
        self.required = attributes[:'required']
      end

      if attributes.has_key?(:'combValueOffset')
        self.comb_value_offset = attributes[:'combValueOffset']
      end

      if attributes.has_key?(:'imageGravity')
        self.image_gravity = attributes[:'imageGravity']
      end

      if attributes.has_key?(:'overflow')
        self.overflow = attributes[:'overflow']
      end

      if attributes.has_key?(:'qrcodeColor')
        self.qrcode_color = attributes[:'qrcodeColor']
      end

      if attributes.has_key?(:'colorFieldRequired')
        self.color_field_required = attributes[:'colorFieldRequired']
      end

      if attributes.has_key?(:'backgroundColorFieldRequired')
        self.background_color_field_required = attributes[:'backgroundColorFieldRequired']
      end

      if attributes.has_key?(:'id')
        self.id = attributes[:'id']
      end

      if attributes.has_key?(:'imageScaleType')
        self.image_scale_type = attributes[:'imageScaleType']
      end

      if attributes.has_key?(:'exclusiveMinimum')
        self.exclusive_minimum = attributes[:'exclusiveMinimum']
      end

      if attributes.has_key?(:'height')
        self.height = attributes[:'height']
      end

      if attributes.has_key?(:'numberConditionRangeExclusiveMax')
        self.number_condition_range_exclusive_max = attributes[:'numberConditionRangeExclusiveMax']
      end

      if attributes.has_key?(:'invertBooleanCondition')
        self.invert_boolean_condition = attributes[:'invertBooleanCondition']
      end

      if attributes.has_key?(:'static')
        self.static = attributes[:'static']
      end

      if attributes.has_key?(:'shapeFillColorFieldName')
        self.shape_fill_color_field_name = attributes[:'shapeFillColorFieldName']
      end

      if attributes.has_key?(:'shapeBorderColorFieldName')
        self.shape_border_color_field_name = attributes[:'shapeBorderColorFieldName']
      end

      if attributes.has_key?(:'vAlignment')
        self.v_alignment = attributes[:'vAlignment']
      end

      if attributes.has_key?(:'bold')
        self.bold = attributes[:'bold']
      end

      if attributes.has_key?(:'shapeBorderWidth')
        self.shape_border_width = attributes[:'shapeBorderWidth']
      end

      if attributes.has_key?(:'combNumberOfCells')
        self.comb_number_of_cells = attributes[:'combNumberOfCells']
      end

      if attributes.has_key?(:'shapeBorderColor')
        self.shape_border_color = attributes[:'shapeBorderColor']
      end

      if attributes.has_key?(:'typeface')
        self.typeface = attributes[:'typeface']
      end

      if attributes.has_key?(:'comb')
        self.comb = attributes[:'comb']
      end

      if attributes.has_key?(:'shapeType')
        self.shape_type = attributes[:'shapeType']
      end

      if attributes.has_key?(:'displayType')
        self.display_type = attributes[:'displayType']
      end

      if attributes.has_key?(:'condition')
        self.condition = attributes[:'condition']
      end

      if attributes.has_key?(:'checkColor')
        self.check_color = attributes[:'checkColor']
      end

      if attributes.has_key?(:'multilineLines')
        self.multiline_lines = attributes[:'multilineLines']
      end

      if attributes.has_key?(:'multiline')
        self.multiline = attributes[:'multiline']
      end

      if attributes.has_key?(:'trueText')
        self.true_text = attributes[:'trueText']
      end

      if attributes.has_key?(:'name')
        self.name = attributes[:'name']
      end

      if attributes.has_key?(:'fontSize')
        self.font_size = attributes[:'fontSize']
      end

      if attributes.has_key?(:'page')
        self.page = attributes[:'page']
      end

      if attributes.has_key?(:'alignment')
        self.alignment = attributes[:'alignment']
      end

      if attributes.has_key?(:'maxLength')
        self.max_length = attributes[:'maxLength']
      end

      if attributes.has_key?(:'autoCalculateMaxLength')
        self.auto_calculate_max_length = attributes[:'autoCalculateMaxLength']
      end

      if attributes.has_key?(:'colorFieldName')
        self.color_field_name = attributes[:'colorFieldName']
      end

      if attributes.has_key?(:'qrcodeColorFieldName')
        self.qrcode_color_field_name = attributes[:'qrcodeColorFieldName']
      end

      if attributes.has_key?(:'numberConditionRangeMin')
        self.number_condition_range_min = attributes[:'numberConditionRangeMin']
      end

      if attributes.has_key?(:'hidden')
        self.hidden = attributes[:'hidden']
      end

      if attributes.has_key?(:'color')
        self.color = attributes[:'color']
      end

      if attributes.has_key?(:'checkColorFieldRequired')
        self.check_color_field_required = attributes[:'checkColorFieldRequired']
      end

      if attributes.has_key?(:'combinedFieldFormat')
        self.combined_field_format = attributes[:'combinedFieldFormat']
      end

      if attributes.has_key?(:'description')
        self.description = attributes[:'description']
      end

      if attributes.has_key?(:'shapeBorderColorFieldRequired')
        self.shape_border_color_field_required = attributes[:'shapeBorderColorFieldRequired']
      end

      if attributes.has_key?(:'combinedFieldNames')
        self.combined_field_names = attributes[:'combinedFieldNames']
      end

      if attributes.has_key?(:'title')
        self.title = attributes[:'title']
      end

      if attributes.has_key?(:'numberConditionRangeExclusiveMin')
        self.number_condition_range_exclusive_min = attributes[:'numberConditionRangeExclusiveMin']
      end

      if attributes.has_key?(:'combinedFieldSeparator')
        self.combined_field_separator = attributes[:'combinedFieldSeparator']
      end

      if attributes.has_key?(:'exclusiveMaximum')
        self.exclusive_maximum = attributes[:'exclusiveMaximum']
      end

      if attributes.has_key?(:'default')
        self.default = attributes[:'default']
      end

      if attributes.has_key?(:'combinedFieldType')
        self.combined_field_type = attributes[:'combinedFieldType']
      end

      if attributes.has_key?(:'dateTimeFormat')
        self.date_time_format = attributes[:'dateTimeFormat']
      end

      if attributes.has_key?(:'qrcodeColorFieldRequired')
        self.qrcode_color_field_required = attributes[:'qrcodeColorFieldRequired']
      end

      if attributes.has_key?(:'currency')
        self.currency = attributes[:'currency']
      end

      if attributes.has_key?(:'strikethrough')
        self.strikethrough = attributes[:'strikethrough']
      end

      if attributes.has_key?(:'falseText')
        self.false_text = attributes[:'falseText']
      end

      if attributes.has_key?(:'characterSpacing')
        self.character_spacing = attributes[:'characterSpacing']
      end

      if attributes.has_key?(:'numberConditionRangeMax')
        self.number_condition_range_max = attributes[:'numberConditionRangeMax']
      end

      if attributes.has_key?(:'backgroundColor')
        self.background_color = attributes[:'backgroundColor']
      end

      if attributes.has_key?(:'checkColorFieldName')
        self.check_color_field_name = attributes[:'checkColorFieldName']
      end

      if attributes.has_key?(:'checkCharacter')
        self.check_character = attributes[:'checkCharacter']
      end

      if attributes.has_key?(:'rotation')
        self.rotation = attributes[:'rotation']
      end

      if attributes.has_key?(:'optionList')
        self.option_list = attributes[:'optionList']
      end

      if attributes.has_key?(:'shapeFillColor')
        self.shape_fill_color = attributes[:'shapeFillColor']
      end

      if attributes.has_key?(:'stringConditionType')
        self.string_condition_type = attributes[:'stringConditionType']
      end

      if attributes.has_key?(:'shapeFillColorFieldRequired')
        self.shape_fill_color_field_required = attributes[:'shapeFillColorFieldRequired']
      end

      if attributes.has_key?(:'includeTime')
        self.include_time = attributes[:'includeTime']
      end

      if attributes.has_key?(:'decimalPlaces')
        self.decimal_places = attributes[:'decimalPlaces']
      end

      if attributes.has_key?(:'x')
        self.x = attributes[:'x']
      end

      if attributes.has_key?(:'width')
        self.width = attributes[:'width']
      end

      if attributes.has_key?(:'maximum')
        self.maximum = attributes[:'maximum']
      end

      if attributes.has_key?(:'y')
        self.y = attributes[:'y']
      end

      if attributes.has_key?(:'signatureAllowDraw')
        self.signature_allow_draw = attributes[:'signatureAllowDraw']
      end

      if attributes.has_key?(:'opacity')
        self.opacity = attributes[:'opacity']
      end

      if attributes.has_key?(:'numberConditionType')
        self.number_condition_type = attributes[:'numberConditionType']
      end

      if attributes.has_key?(:'minimum')
        self.minimum = attributes[:'minimum']
      end

      if attributes.has_key?(:'signatureAllowType')
        self.signature_allow_type = attributes[:'signatureAllowType']
      end
    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      invalid_properties = Array.new
      if !@id.nil? && @id < 0
        invalid_properties.push('invalid value for "id", must be greater than or equal to 0.')
      end

      if !@height.nil? && @height < 0
        invalid_properties.push('invalid value for "height", must be greater than or equal to 0.')
      end

      if !@shape_border_width.nil? && @shape_border_width < 0
        invalid_properties.push('invalid value for "shape_border_width", must be greater than or equal to 0.')
      end

      if !@comb_number_of_cells.nil? && @comb_number_of_cells < 0
        invalid_properties.push('invalid value for "comb_number_of_cells", must be greater than or equal to 0.')
      end

      if !@multiline_lines.nil? && @multiline_lines < 0
        invalid_properties.push('invalid value for "multiline_lines", must be greater than or equal to 0.')
      end

      if !@font_size.nil? && @font_size < 0
        invalid_properties.push('invalid value for "font_size", must be greater than or equal to 0.')
      end

      if !@page.nil? && @page < 1
        invalid_properties.push('invalid value for "page", must be greater than or equal to 1.')
      end

      if !@rotation.nil? && @rotation > 3.6E+2
        invalid_properties.push('invalid value for "rotation", must be smaller than or equal to 3.6E+2.')
      end

      if !@rotation.nil? && @rotation < 0
        invalid_properties.push('invalid value for "rotation", must be greater than or equal to 0.')
      end

      if !@decimal_places.nil? && @decimal_places < 0
        invalid_properties.push('invalid value for "decimal_places", must be greater than or equal to 0.')
      end

      if !@x.nil? && @x < 0
        invalid_properties.push('invalid value for "x", must be greater than or equal to 0.')
      end

      if !@width.nil? && @width < 0
        invalid_properties.push('invalid value for "width", must be greater than or equal to 0.')
      end

      if !@y.nil? && @y < 0
        invalid_properties.push('invalid value for "y", must be greater than or equal to 0.')
      end

      if !@opacity.nil? && @opacity > 1
        invalid_properties.push('invalid value for "opacity", must be smaller than or equal to 1.')
      end

      if !@opacity.nil? && @opacity < 0
        invalid_properties.push('invalid value for "opacity", must be greater than or equal to 0.')
      end

      invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      type_validator = EnumAttributeValidator.new('String', ['string', 'number', 'boolean', 'date', 'address', 'country', 'email', 'url', 'image', 'signature', 'barcode', 'combined'])
      return false unless type_validator.valid?(@type)
      image_gravity_validator = EnumAttributeValidator.new('String', ['NorthWest', 'North', 'NorthEast', 'West', 'Center', 'East', 'SouthWest', 'South', 'SouthEast'])
      return false unless image_gravity_validator.valid?(@image_gravity)
      overflow_validator = EnumAttributeValidator.new('String', ['shrink_to_fit', 'truncate'])
      return false unless overflow_validator.valid?(@overflow)
      return false if !@id.nil? && @id < 0
      image_scale_type_validator = EnumAttributeValidator.new('String', ['fit', 'fill', 'stretch'])
      return false unless image_scale_type_validator.valid?(@image_scale_type)
      return false if !@height.nil? && @height < 0
      v_alignment_validator = EnumAttributeValidator.new('String', ['bottom', 'center', 'top'])
      return false unless v_alignment_validator.valid?(@v_alignment)
      return false if !@shape_border_width.nil? && @shape_border_width < 0
      return false if !@comb_number_of_cells.nil? && @comb_number_of_cells < 0
      shape_type_validator = EnumAttributeValidator.new('String', ['square', 'rectangle', 'circle', 'ellipse'])
      return false unless shape_type_validator.valid?(@shape_type)
      display_type_validator = EnumAttributeValidator.new('String', ['text', 'check', 'qrcode', 'barcode', 'image', 'shape'])
      return false unless display_type_validator.valid?(@display_type)
      return false if !@multiline_lines.nil? && @multiline_lines < 0
      return false if !@font_size.nil? && @font_size < 0
      return false if !@page.nil? && @page < 1
      alignment_validator = EnumAttributeValidator.new('String', ['left', 'center', 'right'])
      return false unless alignment_validator.valid?(@alignment)
      check_character_validator = EnumAttributeValidator.new('String', ['&#10003;', '&#10004;', '&#10006;', '&#10007;', '&#10008;'])
      return false unless check_character_validator.valid?(@check_character)
      return false if !@rotation.nil? && @rotation > 3.6E+2
      return false if !@rotation.nil? && @rotation < 0
      string_condition_type_validator = EnumAttributeValidator.new('String', ['equals', 'contains', 'starts_with', 'ends_with', 'regex'])
      return false unless string_condition_type_validator.valid?(@string_condition_type)
      return false if !@decimal_places.nil? && @decimal_places < 0
      return false if !@x.nil? && @x < 0
      return false if !@width.nil? && @width < 0
      return false if !@y.nil? && @y < 0
      return false if !@opacity.nil? && @opacity > 1
      return false if !@opacity.nil? && @opacity < 0
      number_condition_type_validator = EnumAttributeValidator.new('String', ['equals', 'range', 'gte', 'gt', 'lte', 'lt'])
      return false unless number_condition_type_validator.valid?(@number_condition_type)
      true
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] type Object to be assigned
    def type=(type)
      validator = EnumAttributeValidator.new('String', ['string', 'number', 'boolean', 'date', 'address', 'country', 'email', 'url', 'image', 'signature', 'barcode', 'combined'])
      unless validator.valid?(type)
        fail ArgumentError, 'invalid value for "type", must be one of #{validator.allowable_values}.'
      end
      @type = type
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] image_gravity Object to be assigned
    def image_gravity=(image_gravity)
      validator = EnumAttributeValidator.new('String', ['NorthWest', 'North', 'NorthEast', 'West', 'Center', 'East', 'SouthWest', 'South', 'SouthEast'])
      unless validator.valid?(image_gravity)
        fail ArgumentError, 'invalid value for "image_gravity", must be one of #{validator.allowable_values}.'
      end
      @image_gravity = image_gravity
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] overflow Object to be assigned
    def overflow=(overflow)
      validator = EnumAttributeValidator.new('String', ['shrink_to_fit', 'truncate'])
      unless validator.valid?(overflow)
        fail ArgumentError, 'invalid value for "overflow", must be one of #{validator.allowable_values}.'
      end
      @overflow = overflow
    end

    # Custom attribute writer method with validation
    # @param [Object] id Value to be assigned
    def id=(id)
      if !id.nil? && id < 0
        fail ArgumentError, 'invalid value for "id", must be greater than or equal to 0.'
      end

      @id = id
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] image_scale_type Object to be assigned
    def image_scale_type=(image_scale_type)
      validator = EnumAttributeValidator.new('String', ['fit', 'fill', 'stretch'])
      unless validator.valid?(image_scale_type)
        fail ArgumentError, 'invalid value for "image_scale_type", must be one of #{validator.allowable_values}.'
      end
      @image_scale_type = image_scale_type
    end

    # Custom attribute writer method with validation
    # @param [Object] height Value to be assigned
    def height=(height)
      if !height.nil? && height < 0
        fail ArgumentError, 'invalid value for "height", must be greater than or equal to 0.'
      end

      @height = height
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] v_alignment Object to be assigned
    def v_alignment=(v_alignment)
      validator = EnumAttributeValidator.new('String', ['bottom', 'center', 'top'])
      unless validator.valid?(v_alignment)
        fail ArgumentError, 'invalid value for "v_alignment", must be one of #{validator.allowable_values}.'
      end
      @v_alignment = v_alignment
    end

    # Custom attribute writer method with validation
    # @param [Object] shape_border_width Value to be assigned
    def shape_border_width=(shape_border_width)
      if !shape_border_width.nil? && shape_border_width < 0
        fail ArgumentError, 'invalid value for "shape_border_width", must be greater than or equal to 0.'
      end

      @shape_border_width = shape_border_width
    end

    # Custom attribute writer method with validation
    # @param [Object] comb_number_of_cells Value to be assigned
    def comb_number_of_cells=(comb_number_of_cells)
      if !comb_number_of_cells.nil? && comb_number_of_cells < 0
        fail ArgumentError, 'invalid value for "comb_number_of_cells", must be greater than or equal to 0.'
      end

      @comb_number_of_cells = comb_number_of_cells
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] shape_type Object to be assigned
    def shape_type=(shape_type)
      validator = EnumAttributeValidator.new('String', ['square', 'rectangle', 'circle', 'ellipse'])
      unless validator.valid?(shape_type)
        fail ArgumentError, 'invalid value for "shape_type", must be one of #{validator.allowable_values}.'
      end
      @shape_type = shape_type
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] display_type Object to be assigned
    def display_type=(display_type)
      validator = EnumAttributeValidator.new('String', ['text', 'check', 'qrcode', 'barcode', 'image', 'shape'])
      unless validator.valid?(display_type)
        fail ArgumentError, 'invalid value for "display_type", must be one of #{validator.allowable_values}.'
      end
      @display_type = display_type
    end

    # Custom attribute writer method with validation
    # @param [Object] multiline_lines Value to be assigned
    def multiline_lines=(multiline_lines)
      if !multiline_lines.nil? && multiline_lines < 0
        fail ArgumentError, 'invalid value for "multiline_lines", must be greater than or equal to 0.'
      end

      @multiline_lines = multiline_lines
    end

    # Custom attribute writer method with validation
    # @param [Object] font_size Value to be assigned
    def font_size=(font_size)
      if !font_size.nil? && font_size < 0
        fail ArgumentError, 'invalid value for "font_size", must be greater than or equal to 0.'
      end

      @font_size = font_size
    end

    # Custom attribute writer method with validation
    # @param [Object] page Value to be assigned
    def page=(page)
      if !page.nil? && page < 1
        fail ArgumentError, 'invalid value for "page", must be greater than or equal to 1.'
      end

      @page = page
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] alignment Object to be assigned
    def alignment=(alignment)
      validator = EnumAttributeValidator.new('String', ['left', 'center', 'right'])
      unless validator.valid?(alignment)
        fail ArgumentError, 'invalid value for "alignment", must be one of #{validator.allowable_values}.'
      end
      @alignment = alignment
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] check_character Object to be assigned
    def check_character=(check_character)
      validator = EnumAttributeValidator.new('String', ['&#10003;', '&#10004;', '&#10006;', '&#10007;', '&#10008;'])
      unless validator.valid?(check_character)
        fail ArgumentError, 'invalid value for "check_character", must be one of #{validator.allowable_values}.'
      end
      @check_character = check_character
    end

    # Custom attribute writer method with validation
    # @param [Object] rotation Value to be assigned
    def rotation=(rotation)
      if !rotation.nil? && rotation > 3.6E+2
        fail ArgumentError, 'invalid value for "rotation", must be smaller than or equal to 3.6E+2.'
      end

      if !rotation.nil? && rotation < 0
        fail ArgumentError, 'invalid value for "rotation", must be greater than or equal to 0.'
      end

      @rotation = rotation
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] string_condition_type Object to be assigned
    def string_condition_type=(string_condition_type)
      validator = EnumAttributeValidator.new('String', ['equals', 'contains', 'starts_with', 'ends_with', 'regex'])
      unless validator.valid?(string_condition_type)
        fail ArgumentError, 'invalid value for "string_condition_type", must be one of #{validator.allowable_values}.'
      end
      @string_condition_type = string_condition_type
    end

    # Custom attribute writer method with validation
    # @param [Object] decimal_places Value to be assigned
    def decimal_places=(decimal_places)
      if !decimal_places.nil? && decimal_places < 0
        fail ArgumentError, 'invalid value for "decimal_places", must be greater than or equal to 0.'
      end

      @decimal_places = decimal_places
    end

    # Custom attribute writer method with validation
    # @param [Object] x Value to be assigned
    def x=(x)
      if !x.nil? && x < 0
        fail ArgumentError, 'invalid value for "x", must be greater than or equal to 0.'
      end

      @x = x
    end

    # Custom attribute writer method with validation
    # @param [Object] width Value to be assigned
    def width=(width)
      if !width.nil? && width < 0
        fail ArgumentError, 'invalid value for "width", must be greater than or equal to 0.'
      end

      @width = width
    end

    # Custom attribute writer method with validation
    # @param [Object] y Value to be assigned
    def y=(y)
      if !y.nil? && y < 0
        fail ArgumentError, 'invalid value for "y", must be greater than or equal to 0.'
      end

      @y = y
    end

    # Custom attribute writer method with validation
    # @param [Object] opacity Value to be assigned
    def opacity=(opacity)
      if !opacity.nil? && opacity > 1
        fail ArgumentError, 'invalid value for "opacity", must be smaller than or equal to 1.'
      end

      if !opacity.nil? && opacity < 0
        fail ArgumentError, 'invalid value for "opacity", must be greater than or equal to 0.'
      end

      @opacity = opacity
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] number_condition_type Object to be assigned
    def number_condition_type=(number_condition_type)
      validator = EnumAttributeValidator.new('String', ['equals', 'range', 'gte', 'gt', 'lte', 'lt'])
      unless validator.valid?(number_condition_type)
        fail ArgumentError, 'invalid value for "number_condition_type", must be one of #{validator.allowable_values}.'
      end
      @number_condition_type = number_condition_type
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(o)
      return true if self.equal?(o)
      self.class == o.class &&
          uppercase == o.uppercase &&
          background_color_field_name == o.background_color_field_name &&
          metadata == o.metadata &&
          barcode_symbology == o.barcode_symbology &&
          min_length == o.min_length &&
          integer == o.integer &&
          type == o.type &&
          required == o.required &&
          comb_value_offset == o.comb_value_offset &&
          image_gravity == o.image_gravity &&
          overflow == o.overflow &&
          qrcode_color == o.qrcode_color &&
          color_field_required == o.color_field_required &&
          background_color_field_required == o.background_color_field_required &&
          id == o.id &&
          image_scale_type == o.image_scale_type &&
          exclusive_minimum == o.exclusive_minimum &&
          height == o.height &&
          number_condition_range_exclusive_max == o.number_condition_range_exclusive_max &&
          invert_boolean_condition == o.invert_boolean_condition &&
          static == o.static &&
          shape_fill_color_field_name == o.shape_fill_color_field_name &&
          shape_border_color_field_name == o.shape_border_color_field_name &&
          v_alignment == o.v_alignment &&
          bold == o.bold &&
          shape_border_width == o.shape_border_width &&
          comb_number_of_cells == o.comb_number_of_cells &&
          shape_border_color == o.shape_border_color &&
          typeface == o.typeface &&
          comb == o.comb &&
          shape_type == o.shape_type &&
          display_type == o.display_type &&
          condition == o.condition &&
          check_color == o.check_color &&
          multiline_lines == o.multiline_lines &&
          multiline == o.multiline &&
          true_text == o.true_text &&
          name == o.name &&
          font_size == o.font_size &&
          page == o.page &&
          alignment == o.alignment &&
          max_length == o.max_length &&
          auto_calculate_max_length == o.auto_calculate_max_length &&
          color_field_name == o.color_field_name &&
          qrcode_color_field_name == o.qrcode_color_field_name &&
          number_condition_range_min == o.number_condition_range_min &&
          hidden == o.hidden &&
          color == o.color &&
          check_color_field_required == o.check_color_field_required &&
          combined_field_format == o.combined_field_format &&
          description == o.description &&
          shape_border_color_field_required == o.shape_border_color_field_required &&
          combined_field_names == o.combined_field_names &&
          title == o.title &&
          number_condition_range_exclusive_min == o.number_condition_range_exclusive_min &&
          combined_field_separator == o.combined_field_separator &&
          exclusive_maximum == o.exclusive_maximum &&
          default == o.default &&
          combined_field_type == o.combined_field_type &&
          date_time_format == o.date_time_format &&
          qrcode_color_field_required == o.qrcode_color_field_required &&
          currency == o.currency &&
          strikethrough == o.strikethrough &&
          false_text == o.false_text &&
          character_spacing == o.character_spacing &&
          number_condition_range_max == o.number_condition_range_max &&
          background_color == o.background_color &&
          check_color_field_name == o.check_color_field_name &&
          check_character == o.check_character &&
          rotation == o.rotation &&
          option_list == o.option_list &&
          shape_fill_color == o.shape_fill_color &&
          string_condition_type == o.string_condition_type &&
          shape_fill_color_field_required == o.shape_fill_color_field_required &&
          include_time == o.include_time &&
          decimal_places == o.decimal_places &&
          x == o.x &&
          width == o.width &&
          maximum == o.maximum &&
          y == o.y &&
          signature_allow_draw == o.signature_allow_draw &&
          opacity == o.opacity &&
          number_condition_type == o.number_condition_type &&
          minimum == o.minimum &&
          signature_allow_type == o.signature_allow_type
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Calculates hash code according to all attributes.
    # @return [Fixnum] Hash code
    def hash
      [uppercase, background_color_field_name, metadata, barcode_symbology, min_length, integer, type, required, comb_value_offset, image_gravity, overflow, qrcode_color, color_field_required, background_color_field_required, id, image_scale_type, exclusive_minimum, height, number_condition_range_exclusive_max, invert_boolean_condition, static, shape_fill_color_field_name, shape_border_color_field_name, v_alignment, bold, shape_border_width, comb_number_of_cells, shape_border_color, typeface, comb, shape_type, display_type, condition, check_color, multiline_lines, multiline, true_text, name, font_size, page, alignment, max_length, auto_calculate_max_length, color_field_name, qrcode_color_field_name, number_condition_range_min, hidden, color, check_color_field_required, combined_field_format, description, shape_border_color_field_required, combined_field_names, title, number_condition_range_exclusive_min, combined_field_separator, exclusive_maximum, default, combined_field_type, date_time_format, qrcode_color_field_required, currency, strikethrough, false_text, character_spacing, number_condition_range_max, background_color, check_color_field_name, check_character, rotation, option_list, shape_fill_color, string_condition_type, shape_fill_color_field_required, include_time, decimal_places, x, width, maximum, y, signature_allow_draw, opacity, number_condition_type, minimum, signature_allow_type].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)
      self.class.openapi_types.each_pair do |key, type|
        if type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            self.send("#{key}=", attributes[self.class.attribute_map[key]].map { |v| _deserialize($1, v) })
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          self.send("#{key}=", _deserialize(type, attributes[self.class.attribute_map[key]]))
        end # or else data not found in attributes(hash), not an issue as the data can be optional
      end

      self
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def _deserialize(type, value)
      case type.to_sym
      when :DateTime
        DateTime.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :BOOLEAN
        if value.to_s =~ /\A(true|t|yes|y|1)\z/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        {}.tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        temp_model = DocSpring.const_get(type).new
        temp_model.build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = self.send(attr)
        next if value.nil?
        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end
  end
end
